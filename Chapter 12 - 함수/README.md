## 함수
 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한 것이다.

### 함수를 사용하는 이유 
1. 코드의 재사용
   - 동일한 작업을 반복하는 코드를 하나의 함수로 정의하여 사용하면 효율적이다. 
2.  유지보수의 편의성을 높이고 코드의 신뢰성을 높인다.
3. 함수의 이름을 통해 함수의 역할을 알 수 있어 코드의 가독성이 증가한다.

### 함수 리터럴
함수는 함수 리터럴을 통해 생성을 할 수 있으며 함수 리터럴의 구성요소는 다음과 같다
1. 함수 이름
  - 함수 이름은 식별자로 식별자 네이밍 규칙을 준수해야 한다.
  - 함수 몸체내에서만 참조할 수 있는 식별자이며 생략이 가능하다.
  - 함수 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라고 한다.   
2. 매개변수 목록
 - 0개 이상의 매개변수를 소괄호로 감싸서 쉼표로 구분한다.
 - 매개변수 목록은 순서에 의미가 있으며 함수 몸체 내부에서 변수와 동일하게 취급 된다. (식별자 네이밍 규칙을 준수)    
3. 함수 몸체
  - 함수가 호출 되었을 때 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.
  - 함수의 호출에 의해 실행된다.

 함수 리터럴도 평가 되어 값을 생성하며 함수는 객체이다. 
 
```
  var f = function add(x,y) { // 함수 이름 add , 매개변수 목록 (x, y)
    return x + y;  //함수 몸체 
}
```
## 함수 정의
자바스크립트에서는 함수를 정의하는 4가지 방법이 있다.

| 함수 정의 방식 |  예시 |
|---|---|
| 함수 선언문 |  function add(x,y) { return x + y;} |
| 함수 표현식 |  var add = function ( x, y) { return x + y; }; |
| Function 생성자 함수 | var add = new Function('x', 'y' , 'return x+y');
| 화살표 함수(ES6) | const add = (x,y) => x +y ; |

 ### 함수 선언문
 함수 리터럴에서 함수의 이름은 함수 몸체 내에서만 참조가 가능하다고 하였지만 자바스크립트 엔진에서 함수의 이름과 동일한 식별자를 암묵적으로 생성하고 , 생성한 식별자에 함수 객체를 할당한다.
 때문에 함수의 이름으로 함수를 호출할 수 있게 된 것처럼 보이게 된다.
```
 function add(x,y) { // 리터럴과 달리 함수의 이름을 생략할 수 없다.
  return x + y;
}
```

### 함수 표현식
함수는 객체이며 값의 성질을 갖는 객체인 일급 객체이다. 일급객체이기 때문에 변수에 할당 할 수 있는데 이런 정의 방식을 함수 표현식이라고 한다.
함수표현식은 함수 이름을 생략할 수 있으며 함수 선언문과 함수의 생성 시점이 다르다.   
```
var add = function(x,y) {
  return x+y;
};

console.log(add(2,5)); 
```

### 함수의 생성 시점과 함수 호이스팅
자바스크립트 엔진은 런타임 전에 모든 선언문의 코드가 먼저 실행된다.
함수 선언문으로 정의하는 경우 함수의 이름과 동일한 식별자가 먼저 선언 되며 함수 호이스팅이 발생한다.
그러나 함수 표현식으로 정의하는 경우에는 런타임 전에는 변수 선언이 되며 변수 호이스팅이 발생한다.
함수 표현식은 런타임 시에 평가되어 함수 객체가 된다.

### Function 생성자 함수
Function 생성자 함수를 사용해서는 다음과 같이 함수를 정의한다.  
```
var add = new Function('x', 'y', 'return x + y');
```
다만 Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 클로저를 생성하지 않는 등 함수 표현식, 함수 선언문과 다르게 동작한다.

### 화살표 함수
ES6에서 도입된 함수 선언 방법이며 항상 익명 함수로 정의한다.
생성자 함수로 사용할 수 없으며 , this 바인딩 방식이 다르고 , prototype 프로퍼티가 없고 argument 객체를 생성하지 않는다.
```
const add = (x , y ) => {
  return x + y;
}
```

### 함수 호출
- 함수의 매개변수(parameter) 는 함수 몸체 내부에서만 참조할 수 있다. 즉, 매개변수의 스코프(유효 범위)는 함수 내부다.
- 함수는 매겨변수의 개수와 인수(argument)의 개수가 일치하지 않아도 된다.
- * 인수가 매개변수보다 부족하면, 나머지 매개변수에 대해서는 암묵적으로 undefined
- * 인수가 매개변수보다 많으면, 모든 인수는 암묵적으로 arguments 객체에 프로퍼티로 보관
- 매개 변수로 객체를 사용 할 수 있다.
-  * 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 되는 장점이 있다.
   * 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생한다.  
```
function add(x, y) {
  console.log(x, y); // 1 2
  return x + y;
}

add(1, 2);
console.log(x, y); // 💩 ReferenceError: x is not defined

// 매개변수의 개수 > 인수의 개수 = 나머지 매개변수 undefined
function mul(x, y) {
  console.log(x, y); // 1 undefined
}
mul(1);

// 매개변수의 개수 < 인수의 개수 = arguments 에 보관
function sub(x, y) {
  console.log(arguments); // [Arguments] { '0': 3, '1': 2, '2': 1 }
  return x - y;
}
sub(3, 2, 1); // 1
```

### 반환문
함수는 return 키워드를 사용해 실행 결과를 외부로 반환 할 수 있다.
함수 내부에서 return 키워드를 만나면 즉시 함수를 탈출하며 반환 문 뒤의 문은 실행되지 않는다.
명시적으로 리턴 값을 정하지 않으면 undefined를 리턴한다.

## 다양한 함수의 형태

### 즉시 실행 함수
함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 하며 단 한번만 호출되며 다시 호출 할 수 없다.
() 그룹 연산자로 감싸 정의하고 실행한다.
그룹 연산자를 사용하는 이유는 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서이다.
```
(function () {
//
 } () ); //즉시 실행 함수의 형태

var res = (function () {
  var a = 5;
  var b = 3;
  return a * b;
} ()); // 일반 함수처럼 값을 반환 할 수 있다.

res = (function ( a , b) {
  return a * b;
}(5, 3)); //일반 함수처럼 인수 전달이 가능하다.     

```

### 재귀 함수
함수 내부에서 자기 자신을 호출 하는 함수이다.
반드시 탈출 조건을 만들어야 하며 반복문보다 재귀함수를 사용하는 편이 직관적일 때 한정적으로 사용하는 것이 좋다.
```
function factorial (n) {
  if (n <= 1) return 1; // 탈출 조건
  return n * factorial(n - 1); //재귀 호출
}
```

### 중첩 함수
함수 내부에 정의 된 함수를 중첩 함수 또는 내부함수라고 한다.  중첩 함수를 포함하는 함수를 외부 함수라고 하며 중첩함수는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
클로저와 연관이 있으며 다른 챕터에서 공부한다.

### 콜백함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며 ,매개 변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수는 고차함수라고 한다.
함수 내부에 변경되는 로직을 콜백함수로 전달하여 사용한다.

```
function repeat(num , callbackFuc ) { //repeat 함수의 추상화
  for (var i = 0 ; i < num ; i++){
      callbackFuc(i); //i를 전달하며 f를 호출
  }
}  

function logAll(num) {
  console.log(num)
}

function logOdd(num) {
  if(num % 2 === 1){ //홀 수 일때만
    console.log(num)
  }
}

repeat(5 , logAll);// 0 , 1, 2 , 3, 4
repeat(5, logOdd); //1 3 
```


